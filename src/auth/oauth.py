from typing import Generic, Type, TypeVar

from fastapi.responses import JSONResponse
from google.auth.transport import requests
from google.oauth2 import id_token
from prisma.models import Student
from pydantic import BaseModel

from src.auth.exceptions import RoleNotAllowedException, GoogleAuthException, UndefinedUserTypeException
from src.auth.jwt import JWTHelper
from src.auth.serializers import UserRoles
from src.config import settings
from src.students import serializers as StudentSerializer
from src.students.service import StudentService

ModelType = TypeVar("ModelType", bound=BaseModel)


class OAuthHandler(Generic[ModelType]):
    def __init__(self, model: Type[ModelType], role: UserRoles) -> None:
        """
        OAuth object with default methods to authenticate and verify a user.

        **Parameters**

        * `model`: A Prisma model

        """
        self.model: Type[ModelType] = model
        self.user_type: str = role.value

    async def get_user_id_from_email(self, email: str) -> int | bool:
        user = await self.model.prisma().find_unique(where={"email": email})
        return user.id if user else False

    @staticmethod
    def verify_id_token(token: str) -> dict[str, str]:
        """Verify ID token generated by Google Auth

        Args:
            token (str): The ID token sent by client (generated by Google Auth)

        Raises:
            RuntimeError: If Issuer does not match to Google.

        Returns:
            dict[str, str]: name and email encoded in ID token
        """
        request = requests.Request()
        try:
            id_info: dict[str, any] = id_token.verify_oauth2_token(
                id_token=token, request=request
            )

            if id_info['aud'] not in [
                settings.GOOGLE_CLIENT_ID,
                settings.GOOGLE_APP_DEBUG_CLIENT_ID,
                settings.GOOGLE_APP_RELEASE_CLIENT_ID
            ]:
                raise ValueError('could not verify audience')

            email: str = id_info["email"]
            name: str = id_info["name"]

            return {"name": name, "email": email}
        except Exception as e:
            print(e)
            raise GoogleAuthException(str(e))

    async def student_signup(self, google_id_token: str) -> JSONResponse:
        signup_data: dict[str, str] = OAuthHandler.verify_id_token(google_id_token)
        email: str = signup_data["email"]

        user_id: bool | int = await self.get_user_id_from_email(email)
        if user_id and isinstance(user_id, int):
            return JSONResponse(OAuthHandler.get_jwt(email=email, id=user_id, role=self.user_type))

        student_signup = StudentSerializer.CreateStudent(**signup_data)
        student_service = StudentService()
        new_student: Student = await student_service.create_student(student_signup)

        tokens: dict[str, str] = OAuthHandler.get_jwt(
            email=new_student.email, id=new_student.id, role=self.user_type
        )
        return JSONResponse(tokens)

    async def user_signup(self, signup_data):
        if self.user_type == UserRoles.STUDENT.value:
            return await self.student_signup(signup_data)

        if (
                self.user_type == UserRoles.TEACHER.value
                or self.user_type == UserRoles.ADMIN.value
        ):
            raise RoleNotAllowedException(self.user_type)

        raise UndefinedUserTypeException(self.user_type)

    @staticmethod
    def get_jwt(
            email: str,
            id: int,
            role: str = "",
            organization_id: int | None = None,
            refresh_token=True,
    ) -> dict[str, str]:
        jwt_helper = JWTHelper()
        response: dict[str, str] = {
            "token": jwt_helper.create_token(
                email=email,
                id=id,
                role=role,
                expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES,
                organization_id=organization_id,
            )
        }

        if refresh_token:
            response["refresh_token"] = jwt_helper.create_token(
                email=email,
                id=id,
                role=role,
                expires_in=settings.REFRESH_TOKEN_EXPIRE_MINUTES,
                organization_id=organization_id,
            )

        return response
